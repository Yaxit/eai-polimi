/**
 *********************************************************************************
 * @file    aiApp.c
 * @author  STMicroelectronics - AIS - MCD Team
 * @version $Version$
 * @date    $Date$
 *********************************************************************************
 * @attention
 *
 * <h2><center>COPYRIGHT &copy; 2021 STMicroelectronics</center></h2>
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file in
 * the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *********************************************************************************
 */

/*
 * Description:
 */

/* System headers */
#include <stdlib.h>
#include <stdio.h>

/* header files */
#include "aiTestHelper.h"

/* AI Run-time header files */
#include "ai_platform_interface.h"

/* AI x-cube-ai files */
#include "app_x-cube-ai.h"

#include "services/sysdebug.h"

/* TODO: define the symbol SYS_DBG_AI in the file sysdebug_config.h */
#define SYS_DEBUGF(level, message)      SYS_DEBUGF3(SYS_DBG_AI, level, message)

/* Global variables */


/* -----------------------------------------------------------------------------
 * AI-related functions
 * -----------------------------------------------------------------------------
 */

DEF_DATA_IN;

DEF_DATA_OUT;

struct ai_network_exec_ctx {
  ai_handle handle;
  ai_network_report report;
} net_exec_ctx[AI_MNETWORK_NUMBER] = {0};


#if AI_MNETWORK_DATA_ACTIVATIONS_INT_SIZE != 0
AI_ALIGNED(32)
static ai_u8 activations[AI_MNETWORK_DATA_ACTIVATIONS_INT_SIZE];
#endif

static int aiBootstrap(struct ai_network_exec_ctx *ctx, const char *nn_name)
{
  ai_error err;
  ai_u32 ext_addr;
  ai_u32 sz;

  /* Creating the instance of the  network ------------------------- */
  printf("Creating the network \"%s\"..\r\n", nn_name);

  err = ai_mnetwork_create(nn_name, &ctx->handle, NULL);
  if (err.type) {
    aiLogErr(err, "ai_mnetwork_create");
    return -1;
  }

  /* Initialize the instance --------------------------------------- */
  printf("Initializing the network\r\n");

  if (ai_mnetwork_get_info(ctx->handle,
      &ctx->report)) {
  } else {
    err = ai_mnetwork_get_error(ctx->handle);
    aiLogErr(err, "ai_mnetwork_get_info");
    ai_mnetwork_destroy(ctx->handle);
    ctx->handle = AI_HANDLE_NULL;
    return -2;
  }

  /* Addresses of the weights and activations buffers
   *
   * - @ of the weights buffer is always provided by the multiple network wrapper
   *   thanks to the ai_<network>_data_weights_get() function (see app_x-cube-ai.c file
   *   generated by the X-CUBE-AI plug-in).
   * - @ of the activations buffer can be a local buffer (activations object) or a buffer
   *   located in the external memory (network dependent feature). For the last case,
   *   the address (hard-coded @) is defined by the X-CUBE-AI plug-in and stored in the
   *   multiple network structure (see app_x-cube-ai.c file, ai_network_entry_t definition).
   *   0xFFFFFFFF indicates that the local buffer should be used.
   */
  ai_network_params params = AI_NETWORK_PARAMS_INIT(
      AI_BUFFER_NULL(NULL),
      AI_BUFFER_NULL(NULL)
  );

  if (ai_mnetwork_get_ext_data_activations(ctx->handle, &ext_addr, &sz) == 0) {
    if (ext_addr == 0xFFFFFFFF) {
#if AI_MNETWORK_DATA_ACTIVATIONS_INT_SIZE != 0
      params.activations.data = (ai_handle)activations;
      if (sz > AI_MNETWORK_DATA_ACTIVATIONS_INT_SIZE) {
        printf("E: APP error (aiBootstrap for %s) - size of the local activations buffer is not enough\r\n",
            nn_name);
        ai_mnetwork_destroy(ctx->handle);
        ctx->handle = AI_HANDLE_NULL;
        return -5;
      }
#else
      if (ctx->report.activations.channels != 0) {
        printf("E: APP error (aiBootstrap for %s) - a local activations buffer is requested\r\n",
            nn_name);
        ai_mnetwork_destroy(ctx->handle);
        ctx->handle = AI_HANDLE_NULL;
        return -5;
      } else {
        params.activations.data = AI_HANDLE_NULL;
      }
#endif
    }
    else {
      params.activations.data = (ai_handle)ext_addr;
    }
  }

  if (!ai_mnetwork_init(ctx->handle, &params)) {
    err = ai_mnetwork_get_error(ctx->handle);
    aiLogErr(err, "ai_mnetwork_init");
    ai_mnetwork_destroy(ctx->handle);
    ctx->handle = AI_HANDLE_NULL;
    return -4;
  }

  /* Display the network info -------------------------------------- */
  if (ai_mnetwork_get_info(ctx->handle,
      &ctx->report)) {
    aiPrintNetworkInfo(&ctx->report);
  } else {
    err = ai_mnetwork_get_error(ctx->handle);
    aiLogErr(err, "ai_mnetwork_get_info");
    ai_mnetwork_destroy(ctx->handle);
    ctx->handle = AI_HANDLE_NULL;
    return -2;
  }

  return 0;
}

static void aiPrintLayoutBufferToFile(FILE *out, const char *msg, int idx, const ai_buffer* buffer)
{
  uint32_t type_id = AI_BUFFER_FMT_GET_TYPE(buffer->format);
  fprintf(out, "%s[%d] ",msg, idx);
  if (type_id == AI_BUFFER_FMT_TYPE_Q) {
    fprintf(out, " %s%d,",
        AI_BUFFER_FMT_GET_SIGN(buffer->format)?"s":"u",
            (int)AI_BUFFER_FMT_GET_BITS(buffer->format));
    if (AI_BUFFER_META_INFO_INTQ(buffer->meta_info)) {
      ai_float scale = AI_BUFFER_META_INFO_INTQ_GET_SCALE(buffer->meta_info, 0);
      int zero_point = AI_BUFFER_META_INFO_INTQ_GET_ZEROPOINT(buffer->meta_info, 0);
      fprintf(out, " scale=%f, zero=%d,", scale, zero_point);
    } else {
      fprintf(out, "Q%d.%d,",
          (int)AI_BUFFER_FMT_GET_BITS(buffer->format)
          - ((int)AI_BUFFER_FMT_GET_FBITS(buffer->format) +
              (int)AI_BUFFER_FMT_GET_SIGN(buffer->format)),
              AI_BUFFER_FMT_GET_FBITS(buffer->format));
    }
  }
  else if (type_id == AI_BUFFER_FMT_TYPE_FLOAT)
    fprintf(out, " float%d,",
        (int)AI_BUFFER_FMT_GET_BITS(buffer->format));
  else if (type_id == AI_BUFFER_FMT_TYPE_BOOL)
    fprintf(out, " bool,");
  else
    fprintf(out, "NONE");
  fprintf(out, " %d bytes, shape=(%d,%d,%d)",
      (int)AI_BUFFER_BYTE_SIZE(AI_BUFFER_SIZE(buffer), buffer->format),
      buffer->height, buffer->width, (int)buffer->channels);
  if (buffer->data)
    fprintf(out, " (@0x%08x)\r\n", (int)buffer->data);
  else
    fprintf(out, " (USER domain)\r\n");
}

/* -----------------------------------------------------------------------------
 * Exported/Public functions
 * -----------------------------------------------------------------------------
 */

int aiProcess(float * p_inData, float p_out_data[2])
{
  ai_i32 batch;
  const int idx = 0; /* only one fixed network */
  ai_buffer ai_input[AI_MNETWORK_IN_NUM];
  ai_buffer ai_output[AI_MNETWORK_OUT_NUM];

  if(net_exec_ctx[idx].handle == AI_HANDLE_NULL)
  {
    printf("E: network handle is NULL\r\n");
    return -1;
  }

  if((net_exec_ctx[idx].report.n_inputs > AI_MNETWORK_IN_NUM) || (net_exec_ctx[idx].report.n_outputs > AI_MNETWORK_OUT_NUM))
  {
    printf("E: AI_MNETWORK_IN/OUT_NUM definition are incoherent\r\n");
    return -1;
  }

  /* Fill the input tensor descriptors */
  for(int i = 0; i < net_exec_ctx[idx].report.n_inputs; i++)
  {
    ai_input[i] = net_exec_ctx[idx].report.inputs[i];
    ai_input[i].n_batches = 1;
    if(net_exec_ctx[idx].report.inputs[i].data)
      ai_input[i].data = AI_HANDLE_PTR(net_exec_ctx[idx].report.inputs[i].data);
    else
      ai_input[i].data = AI_HANDLE_PTR(data_ins[i]);
  }

  /* Fill the output tensor descriptors */
  for(int i = 0; i < net_exec_ctx[idx].report.n_outputs; i++)
  {
    ai_output[i] = net_exec_ctx[idx].report.outputs[i];
    ai_output[i].n_batches = 1;
    if(net_exec_ctx[idx].report.outputs[i].data)
      ai_output[i].data = AI_HANDLE_PTR(net_exec_ctx[idx].report.outputs[i].data);
    else
      ai_output[i].data = AI_HANDLE_PTR(data_outs[i]);
  }

  /* Fill input tensors with data from sensor */
  for(int i = 0; i < net_exec_ctx[idx].report.n_inputs; i++)
  {
    ai_i8 *in_data = (ai_i8*) ai_input[i].data;
    for(ai_size j = 0; j < AI_BUFFER_SIZE(&ai_input[i]); ++j)
    {
      *(ai_float*) (in_data + j * sizeof(float)) = *p_inData++;
    }
  }

  /* execute inference */
  batch = ai_mnetwork_run(net_exec_ctx[idx].handle, ai_input, ai_output);

  if( AI_NETWORK_OUT_NUM == 2)
  {
    float *p_out0 = (float*) ai_output[0].data;
    float *p_out1 = (float*) ai_output[1].data;
    //  SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE,("%d | %f\n\r", (int)p_out0[0] ,p_out1 [(int)p_out0[0]]));

    p_out_data[0] = p_out0[0];
    p_out_data[1] = p_out1[(int) p_out0[0]];
  }
  else if( AI_NETWORK_OUT_NUM == 1)
  {
    float *p_out0 = (float*) ai_output[0].data;
    float max_out = *p_out0;
    int max_idx = 0;
    for(int i = 1; i < AI_NETWORK_OUT_1_CHANNEL; i++)
    {
      if(p_out0[i] > max_out)
      {
        max_idx = i;
        max_out = p_out0[i];
      }
    }
    //    SYS_DEBUGF(SYS_DBG_LEVEL_VERBOSE, ("%d | %f\n\r",max_idx,max_out));

    p_out_data[0] = max_idx;
    p_out_data[1] = max_out;
  }

  if(batch != 1)
  {
    aiLogErr(ai_mnetwork_get_error(net_exec_ctx[idx].handle), "ai_mnetwork_run");
  }

  return 0;
}

int aiInit(void)
{
  int res = -1;
  const char *nn_name;
  int idx;

  aiPlatformVersion();

  /* Reset the contexts -------------------------------------------- */
  for (idx=0; idx < AI_MNETWORK_NUMBER; idx++) {
    net_exec_ctx[idx].handle = AI_HANDLE_NULL;
  }

  /* Discover and initialize the network(s) ------------------------ */
  printf("Discovering the network(s)...\r\n");

  idx = 0;
  do {
    nn_name = ai_mnetwork_find(NULL, idx);
    if (nn_name) {
      printf("\r\nFound network \"%s\"\r\n", nn_name);
      res = aiBootstrap(&net_exec_ctx[idx], nn_name);
      if (res)
        nn_name = NULL;
    }
    idx++;
  } while (nn_name);

  return res;
}

void aiDeInit(void)
{
  ai_error err;
  int idx;

  /* Releasing the instance(s) ------------------------------------- */
  printf("Releasing the instance(s)...\r\n");

  for (idx=0; idx<AI_MNETWORK_NUMBER; idx++) {
    if (net_exec_ctx[idx].handle != AI_HANDLE_NULL) {
      if (ai_mnetwork_destroy(net_exec_ctx[idx].handle)
          != AI_HANDLE_NULL) {
        err = ai_mnetwork_get_error(net_exec_ctx[idx].handle);
        aiLogErr(err, "ai_mnetwork_destroy");
      }
      net_exec_ctx[idx].handle = AI_HANDLE_NULL;
    }
  }
}

void aiPrintNetworkInfoToFile(FILE *out)
{
  if (ai_mnetwork_get_info(net_exec_ctx[0].handle, &net_exec_ctx[0].report))
  {
    int i;
    ai_network_report *report = &net_exec_ctx[0].report;
    fprintf(out, "Network informations...\r\n");
    fprintf(out, " model name         : %s\r\n", report->model_name);
    fprintf(out, " model signature    : %s\r\n", report->model_signature);
    fprintf(out, " model datetime     : %s\r\n", report->model_datetime);
    fprintf(out, " compile datetime   : %s\r\n", report->compile_datetime);
    fprintf(out, " runtime version    : %d.%d.%d\r\n",
        report->runtime_version.major,
        report->runtime_version.minor,
        report->runtime_version.micro);
    if (report->tool_revision[0])
      fprintf(out, " Tool revision      : %s\r\n", (report->tool_revision[0])?report->tool_revision:"");
    fprintf(out, " tools version      : %d.%d.%d\r\n",
        report->tool_version.major,
        report->tool_version.minor,
        report->tool_version.micro);
    fprintf(out, " complexity         : %d MACC\r\n", (int)report->n_macc);
    fprintf(out, " c-nodes            : %d\r\n", (int)report->n_nodes);
    fprintf(out, " activations        : %d bytes (0x%08x)\r\n",
        (int)AI_BUFFER_SIZE(&report->activations), (int)report->activations.data);
    fprintf(out, " weights            : %d bytes (0x%08x)\r\n",
        (int)AI_BUFFER_SIZE(&report->params), *(int*)report->params.data);
    fprintf(out, " inputs/outputs     : %u/%u\r\n", report->n_inputs,
        report->n_outputs);
    for (i=0; i<report->n_inputs; i++)
      aiPrintLayoutBufferToFile(out, "  I", i, &report->inputs[i]);
    for (i=0; i<report->n_outputs; i++)
      aiPrintLayoutBufferToFile(out, "  O", i, &report->outputs[i]);
  }
}

